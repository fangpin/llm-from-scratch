# 从 0 搭建 LLM 不再难！这个 PyTorch 项目帮你吃透 Transformer 底层逻辑

如果你曾想深入理解大语言模型（LLM）的 “五脏六腑”，却被框架封装的黑盒接口、复杂的源码结构劝退；如果你希望亲手实现 Transformer 的每一个组件，而非单纯调用`transformers`库 —— 那么今天推荐的这个开源项目，绝对能成为你的 LLM 学习 “脚手架”。

它就是 GitHub 上的 **llm-from-scratch**（[项](https://github.com/fangpin/llm-from-scratch)[目地址](https://github.com/fangpin/llm-from-scratch)），一个基于 PyTorch、专为教育设计的 “全手工” LLM 实现方案。从注意力机制到优化器，从 Tokenizer 到训练脚本，所有代码都模块化、易读且无过度封装，帮你真正 “拨开迷雾见本质”。

## 一、项目定位：不止是代码，更是 LLM 学习手册

不同于工业级 LLM 项目追求性能优化，`llm-from-scratch`的核心目标是 \*\*“教学导向”\*\*：让学习者能一步步看到 LLM 的构建过程，理解每个组件的作用与原理。

项目作者用 PyTorch 从零实现了现代解码器 - only Transformer（类似 GPT 架构）的完整生态，小到`Softmax`函数，大到训练全流程，每一行代码都为 “易懂” 服务。无论是 AI 入门者想打牢基础，还是资深开发者想复盘 LLM 底层逻辑，都能从这个项目中获益。

## 二、核心特色：6 大亮点，解决 LLM 学习痛点

### 1. 真正 “从 0 实现”：拒绝黑盒，吃透底层

项目最核心的优势是**无依赖式组件开发**—— 没有直接调用 PyTorch 原生的`nn.MultiHeadAttention`或`nn.LayerNorm`，而是自己手写了每一个核心模块：

* 从`ScaledDotProductAttention`（缩放点积注意力）到`MultiHeadAttention`（多头注意力），能清晰看到 “注意力分数计算→掩码→softmax→加权求和” 的完整流程；

* 从`RmsNorm`（RMS 归一化）到`FFN`（前馈网络），甚至`Linear`层、`Softmax`函数、`CrossEntropyLoss`损失函数，都有独立实现代码，帮你理解数值计算细节。

比如在`llm/transformer.py`中，`ScaledDotProductAttention`的代码直接展示了 “QK^T 缩放→掩码→softmax→与 V 相乘” 的步骤，注释清晰，新手也能看懂注意力机制的本质。

### 2. 现代架构：对齐 SOTA LLM 技术

项目没有停留在 “基础 Transformer” 层面，而是集成了当前主流 LLM 的关键技术，让你学到的不仅是 “过时知识”，更是工业界实践方案：

* **RMSNorm**：替代传统 LayerNorm，计算更高效、训练更稳定（无需计算均值，仅需 Root Mean Square）；

* **SwiGLU 激活函数**：在 FFN 层中使用，比 ReLU、GELU 更能提升模型表达能力（通过门控机制动态调整输出）；

* **RoPE（旋转位置编码）**：摒弃固定 positional embedding，通过旋转 Q/K 向量注入位置信息，更适合长序列处理；

* **自定义 BPE Tokenizer**：在`llm/bpe_tokenizer.py`中从零实现 Byte Pair Encoding，支持在任意文本语料上训练，还能自定义特殊 token（如`<|endoftext|>`）。

### 3. 全流程工具链：从训练到生成，一站式覆盖

学会组件实现只是第一步，LLM 的完整链路还包括数据处理、训练、推理 —— 这些项目都帮你准备好了：

* **数据准备**：提供脚本下载常用训练语料（如 TinyStories、OWT 样本集），并支持将文本转为内存映射的 numpy 数组（高效加载大数据）；

* **训练脚本**（`llm/training.py`）：包含数据加载、训练循环、验证、 checkpoint 保存 / 加载，甚至支持梯度裁剪，新手也能快速启动训练；

* **生成脚本**（`llm/generating.py`）：基于训练好的模型，支持 top-p 采样生成文本，可直接测试模型效果；

* **优化器工具**：自定义实现`AdamW`（带权重衰减的 Adam）和`SGDDecay`（带学习率衰减的 SGD），还配套余弦学习率调度器（带 warmup），覆盖 LLM 训练常用优化策略。

### 4. 严苛测试：确保代码正确性，放心学习

为了避免 “学错知识”，项目配备了全面的测试套件：

* 基于`pytest`和快照测试，验证每个模块的输出是否符合预期（如注意力机制的输出是否与参考实现一致）；

* 覆盖范围广：包括 Transformer 组件、BPE Tokenizer 的编码 / 解码 / 训练过程、优化器的梯度更新逻辑等；

* 新手可通过阅读测试用例，反向理解 “正确的组件应该满足什么条件”（比如 Tokenizer 编码后再解码，需能还原原始文本）。

### 5. 中文友好：文档与注释无语言障碍

项目提供`README_cn.md`中文文档，关键代码也有清晰注释，国内开发者无需再为 “看英文文档查词典” 烦恼。无论是环境配置、使用步骤还是组件说明，中文文档都讲得明明白白，降低上手门槛。

### 6. 模块化结构：按需学习，灵活扩展

项目目录设计清晰，每个功能模块独立成文件，方便按需查阅：

```
llm/

├── transformer.py  # 核心Transformer组件（模型、注意力、FFN等）

├── bpe\_tokenizer.py  # BPE Tokenizer实现

├── training.py     # 训练脚本

├── generating.py   # 文本生成脚本

├── checkpoint.py   # 模型 checkpoint 工具

└── ...
```

比如你只想学 RoPE 的实现，直接看`transformer.py`中的`RoPE`类即可；想了解 BPE 原理，重点读`bpe_tokenizer.py`就行，无需在海量代码中 “找线索”。

## 三、快速上手：4 步跑通 LLM 训练与生成

看完特色，是不是想立刻动手试试？项目的使用流程非常简洁，即使是新手，跟着步骤也能快速启动。

### 1. 环境准备

首先克隆项目，并安装依赖（项目用`uv`管理依赖，比`pip`更高效）：

```
\# 克隆项目

git clone https://github.com/fangpin/llm-from-scratch.git

cd llm-from-scratch

\# 安装依赖（需先安装uv：https://docs.astral.sh/uv/getting-started/installation/）

uv sync
```

### 2. 准备训练数据

项目支持主流公开语料，直接用脚本下载即可（以 TinyStories 和 OWT 样本集为例）：

```
\# 创建数据目录

mkdir -p data

cd data

\# 下载TinyStories（适合小模型快速验证）

wget https://huggingface.co/datasets/roneneldan/TinyStories/resolve/main/TinyStoriesV2-GPT4-train.txt

wget https://huggingface.co/datasets/roneneldan/TinyStories/resolve/main/TinyStoriesV2-GPT4-valid.txt

\# 下载OWT样本集（更大的通用语料）

wget https://huggingface.co/datasets/stanford-cs336/owt-sample/resolve/main/owt\_train.txt.gz

gunzip owt\_train.txt.gz

wget https://huggingface.co/datasets/stanford-cs336/owt-sample/resolve/main/owt\_valid.txt.gz

gunzip owt\_valid.txt.gz

\# 返回项目根目录

cd ..
```

如果用自己的语料，只需将多个文本文件用`<|endoftext|>`拼接（作为文本分隔符）即可。

### 3. 训练 BPE Tokenizer

先训练 Tokenizer（将文本转为模型能理解的 token ID）：

```
uv run -m llm.bpe\_tokenizer
```

训练完成后，会生成词汇表和合并规则，后续训练和生成都会用到。

### 4. 训练 LLM 模型

启动模型训练（可根据硬件调整参数，如 batch size、模型层数等）：

```
uv run -m llm.training
```

训练过程中会自动保存 checkpoint、打印损失曲线，还支持验证集评估。项目提供的损失曲线显示，训练 10000 步后损失稳定下降，学习率也会按余弦调度动态调整，确保训练稳定。

### 5. 生成文本

训练完成后，用训练好的模型生成文本：

```
uv run -m llm.generating
```

只需输入提示词（如 “Once upon a time”），模型就会用 top-p 采样生成连贯的文本，直观感受自己训练的 LLM 效果。

### 6. 运行测试（可选）

如果想验证组件正确性，运行测试套件：

```
uv run pytest
```

## 四、为什么推荐这个项目？3 个核心价值

1. **学习成本低**：无过度封装，代码注释清晰，中文文档友好，新手能快速入门；

2. **实用性强**：覆盖 LLM 全流程，从 Tokenizer 到训练生成，学完就能动手做自己的小模型；

3. **适配前沿技术**：集成 RMSNorm、RoPE 等现代技术，学到的知识能对接工业界 SOTA 模型（如 GPT-4、Llama）。

## 五、后续探索与贡献

如果你在使用中发现 bug，或想增加新功能（如支持 LoRA 微调、添加更多注意力变体），项目非常欢迎贡献：

* 提交 Pull Request：完善代码或文档；

* 开启 Issue：反馈问题或提出建议；

* 分享你的训练成果：比如用该项目训练的模型生成的有趣文本，或优化后的训练方案。

项目采用 MIT 许可证，可自由用于学习、研究或商业非商业项目，无需担心版权问题。

## 结语

学习 LLM 的最好方式，从来不是 “看一百篇文章”，而是 “亲手写一遍代码”。`llm-from-scratch`就像一位 “耐心的导师”，把复杂的 Transformer 拆成一个个可理解的组件，帮你从 “会用 LLM” 进阶到 “懂 LLM”。

无论你是学生、开发者还是 AI 爱好者，都不妨现在就克隆项目，跟着代码一步步搭建自己的第一个 LLM—— 相信我，当你看到自己训练的模型生成文本时，那种成就感会让你对 LLM 的理解更上一层楼。

👉 立即探索项目：[https://github.com/fangpin/llm-from-scratch](https://github.com/fangpin/llm-from-scratch)

